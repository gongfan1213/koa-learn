# 第二章

## 中间件的使用

- 运行原理就是洋葱圈模型，，每一个中间件就相当于洋葱的一层结构，不同的中间件可以实现不同的功能
- 应用程序，路由中间件，会话中间件，缓存中间件，错误处理器，状态码重定向，注册管理器

```js
const Koa = require('koa');
const app = new Koa();
app.use(async (ctx,next) => {
    console.log('1')
    await next()
    console.log('6')
}) 
app.use(async(ctx,next) => {
    console.log('2')
    await next()
    console.log('5')
})
app.use(async(ctx, next) => {
    console.log('3')
    await next()
    console.log('4')
})
app.listen(4000, () => {
    console.log('server is running,port is 4000')
})

//app.use是一个回调函数，该回调函数有两个参数的，一个是ctx一个是next函数，
```

## 路由应该怎么写

- 路由的广义概念是通过互联网把信息从源地址传输到目的地址的活动
- 前端路由：浏览器提供了监听URL的相关的事件，用于进行相关的处理
- 后端路由：拿到请求的对象里的URL根据URL实现相应的逻辑
- Koa路由：1.原生路由的实现，通过request对象的URL属性进行判断2.koa-router中间件来实现路由
### 原生路由
- 通过判断request对象的URL属性做相应的处理

```js
const Koa = require('koa');
const app = new Koa();
app.use(async (ctx) => {
    const url = ctx.request.url 
    let content =''
    switch(url) {
        case '/api/get/userInfo':
            content ='200:this is getUserInfo request'
            break;
        case '/api/update/userInfo':
            content = '200: this is updateUserInfo request'
            break;
        default:
            content = '404: no router match'
            break;
    }
    ctx.body = content
})
app.listen(4000)
console.log('server is running,port is 4000')
```
## 在实际项目当中利用koa-router实现的

- npm install --save koa-router



  ```js
  const Koa = require('koa');
const app = new Koa();
const Router = require('koa-router');
const router = new Router()
router.get('/api/get/userInfo',async( ctx) => {
    ctx.body = '200: this is getUserInfo request'
});
router.get('/api/update/usrInfo', async(ctx) => {
    ctx.body = '200: this is updateUserInfo request'
})
//加载路由中间件
app.use(router.routes()).use( async(ctx) => {
    ctx.body = '404 : no  router match'
})
app.listen(4000, () => {
    console.log('server is running,port is 4000')
})
```
- tree查看目录结构
## 静态服务器
- 静态服务器起到了一个提供一个读取静态文件包括js,css,png文件),静态目录的作用

#### 两种方式实现
- 1.利用koa查看中间件原理
- 2.原生方式实现的

### koa-static中间件的使用

- npm install --save koa-static

- static目录下存放的是静态文件，index.hs文件时koa部分的逻辑实现

```js
const Koa = require('koa')
const path = require('path')
const static = require('koa-static')

const app = new Koa();
const staticPath = './static'
app.use(static(path.join(__dirname,staticPath)))
app.listen(4000, () => {
    console.log('server is running,port is 4999')
})
```

### 如何实现一个静态服务器

- 思路就是通过请求的URL来读取静态文件，静态服务器通过请求把内容展示到页面上的

```js
const Koa = require('koa')
const path = require('path')
const fs = require('fs')
const MIMES_MAP = {
    'css' :'text/css',
    'html':'text/html',
    'jpg':'image/jpeg'
}
const app = new Koa();
const staticPath = './static';
//解析资源类型
function parseMime(url ) {
    let extName = path.extname(url);
    extName = extName? extName.slice(1):'unknown'
    return MIMES_MAP[extName];
}
app.use( async (ctx) => {
    //静态资源目录在本地的绝对路径

    let fullStaticPath = path.join(__dirname,staticPath);
    //获取静态资源的内容，有可能时文件内容，目录或者404
    let content = fs.readFileSync(path.join(fullStaticPath,ctx.url),'binary');
    //解析请求内容的类型
    let mime = parseMime(ctx.url);
    //如果有对应的文件类型，就配置对应的上下文类型
    if (mime) {
        ctx.type = mime;
    }
    //输出静态资源的内容
    if(mime && mime.indexOf('image/') >= 0) {
        //如果时图片，则用Node原生res，输出二进制的数据
        ctx.res.writeHead(200)
        ctx.res.write(content,'binary')
        ctx.res.end()
    } else {
        //其他就输出文本
        ctx.body = content
    }
})
app.listen(4000,() => {
    console.log('SERR is running port is 000')
})
//通过一个map来对静态资源类型和mime type做映射，再依据请求当中的url来读取对应的资源，再将其放回到前端进行展示的
```
在javascript当中，要善于利用map做代码优化，比如if-else,switch case的逻辑，多数情况可以利用map来重写的

